{
  "hash": "9f29470066e4e1e6658b57d082a049ee",
  "result": {
    "markdown": "# Import et export de données\n\nAvant de pouvoir effectuer des analyses sur des données, il est souvent nécessaire de les importer dans un logiciel de traitement. La programmation en langage R offre une multitude de fonctions pour importer et exporter des données. Dans ce chapitre, nous verrons comment importer des données provenant de fichiers, de bases de données, du web et d'autres sources, ainsi que comment exporter des données dans différents formats. Grâce à ce chapitre, vous serez en mesure de travailler avec des jeux de données variés dans R, et ainsi, explorerez les analyses et les visualisations de données sous un nouvel angle.\n\nIl est très vivement conseillé de travailler avec les projets de RStudio pour faciliter l'accès aux fichiers et pouvoir regrouper l'ensemble des éléments d'une analyse dans un dossier\n\nAprès importation, il est important de vériefier que celle-ci s'est bien déroulée à l'aide de certaines fonctions génériques tel que `dim()` pour la dimension(nombre de lignes et colonnes), `str()` pour connaitre la nature des variables, `head()` et `tail()` pour afficher respectivement les premières et dernières lignes du tableau.\n\n## Importer un fichier texte\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sep = \"\\t\"\nhotdogs <- read.delim(\"data/hotdogs.txt\", header = F)\nhead(hotdogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    V1  V2  V3\n1 Beef 186 495\n2 Beef 181 477\n3 Beef 176 425\n4 Beef 149 322\n5 Beef 184 482\n6 Beef 190 587\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhotdogs <- read.table(\"data/hotdogs.txt\", sep = \"\\t\")\nhead(hotdogs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    V1  V2  V3\n1 Beef 186 495\n2 Beef 181 477\n3 Beef 176 425\n4 Beef 149 322\n5 Beef 184 482\n6 Beef 190 587\n```\n:::\n:::\n\n\n\n## Importer un fichier csv\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.csv(\"data/swimming_pools.csv\")\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t20 obs. of  4 variables:\n $ Name     : chr  \"Acacia Ridge Leisure Centre\" \"Bellbowrie Pool\" \"Carole Park\" \"Centenary Pool (inner City)\" ...\n $ Address  : chr  \"1391 Beaudesert Road, Acacia Ridge\" \"Sugarwood Street, Bellbowrie\" \"Cnr Boundary Road and Waterford Road Wacol\" \"400 Gregory Terrace, Spring Hill\" ...\n $ Latitude : num  -27.6 -27.6 -27.6 -27.5 -27.4 ...\n $ Longitude: num  153 153 153 153 153 ...\n```\n:::\n:::\n\n\n\n`stringsAsFactors = T` permet de transformer les chaînes de caractères en facteurs.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.csv(\"data/swimming_pools.csv\", stringsAsFactors = T)\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t20 obs. of  4 variables:\n $ Name     : Factor w/ 20 levels \"Acacia Ridge Leisure Centre\",..: 1 2 3 4 5 6 19 7 8 9 ...\n $ Address  : Factor w/ 20 levels \"1 Fairlead Crescent, Manly\",..: 5 20 18 10 9 11 6 15 12 17 ...\n $ Latitude : num  -27.6 -27.6 -27.6 -27.5 -27.4 ...\n $ Longitude: num  153 153 153 153 153 ...\n```\n:::\n:::\n\n\n\nLe package `readr` contient des fonctions permettant importer les fichiers csv. Nous avons par exemple `read_csv()`, `read_tsv()` et `read_delim()`. Vous pouvez obtenir de l'aide pour ces fonctions en tapant par exemple `?readr:: read_tsv()`. Les fonctions du package `readr` sont connues pour être un peu plus rapides que les cellec du package de base. Ces fonctions importent les données sous forme de `tibble` qui est une forme améliorée du data.frame.\n\n## Importer un fichier Excel\n\nPour lire des fichiers Excel, nous pouvons utiliser le package `readxl`. `excel_sheets()` permet de savoir les différentes feuilles du classeur et `read_excel()` importe les données sous forme de tibble/data.frame.\n\nPar défaut, lorsque nous affichons un tibble, seul les 10 premières lignes sont rétournées.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read_excel(\"data/urbanpop.xls\", sheet = 1)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 209 x 8\n   country               `1960`    `1961`    `1962`  `1963` `1964` `1965` `1966`\n   <chr>                  <dbl>     <dbl>     <dbl>   <dbl>  <dbl>  <dbl>  <dbl>\n 1 Afghanistan           769308   814923.   858522.  9.04e5 9.51e5 1.00e6 1.06e6\n 2 Albania               494443   511803.   529439.  5.47e5 5.66e5 5.84e5 6.03e5\n 3 Algeria              3293999  3515148.  3739963.  3.97e6 4.22e6 4.49e6 4.65e6\n 4 American Samoa            NA    13660.    14166.  1.48e4 1.54e4 1.60e4 1.67e4\n 5 Andorra                   NA     8724.     9700.  1.07e4 1.19e4 1.31e4 1.42e4\n 6 Angola                521205   548265.   579695.  6.12e5 6.45e5 6.79e5 7.18e5\n 7 Antigua and Barbuda    21699    21635.    21664.  2.17e4 2.18e4 2.19e4 2.20e4\n 8 Argentina           15224096 15545223. 15912120.  1.63e7 1.67e7 1.70e7 1.74e7\n 9 Armenia               957974  1008597.  1061426.  1.12e6 1.17e6 1.23e6 1.28e6\n10 Aruba                  24996    28140.    28533.  2.88e4 2.89e4 2.91e4 2.93e4\n# ... with 199 more rows\n```\n:::\n:::\n\n\n\n## Importer des fichier SPSS, SAS et Stata\n\nSouvent, les fichiers que nous voulons dans R proviennes des logiciels comme SPSS ou Stata. Les package `haven` et `foreign` dispose des fonctions permettant importer des différents fichiers. Il est toujours important de consulter la documentation pour avoir plus de détails.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(haven)\n```\n:::\n\n\n\n-   fichier SAS\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsales <- read_sas(\"data/sales.sas7bdat\")\nstr(sales)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [431 x 4] (S3: tbl_df/tbl/data.frame)\n $ purchase: num [1:431] 0 0 1 1 0 0 0 0 0 0 ...\n $ age     : num [1:431] 41 47 41 39 32 32 33 45 43 40 ...\n $ gender  : chr [1:431] \"Female\" \"Female\" \"Female\" \"Female\" ...\n $ income  : chr [1:431] \"Low\" \"Low\" \"Low\" \"Low\" ...\n```\n:::\n:::\n\n\n\n-   fichier Stata\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflorida <- read_dta(\"data/edequality.dta\")\ntail(florida)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 27\n   hhid hhweight location region  ethni~1   age gender  relat~2 literate incom~3\n  <dbl>    <dbl> <dbl+lb> <dbl+l> <dbl+l> <dbl> <dbl+l> <dbl+l> <dbl+lb>   <dbl>\n1  4298     627.  2 [rur~ 3 [Var~ 2 [Tur~    17 1 [mal~ 3 [chi~  2 [yes]   212. \n2  4299     627.  2 [rur~ 3 [Var~ 1 [Bul~    74 1 [mal~ 1 [hea~  2 [yes]   206. \n3  4299     627.  2 [rur~ 3 [Var~ 1 [Bul~    75 2 [fem~ 2 [spo~  2 [yes]   206. \n4  4300     627.  1 [urb~ 3 [Var~ 1 [Bul~    57 1 [mal~ 1 [hea~  2 [yes]   250  \n5   181     627.  2 [rur~ 6 [Plo~ 1 [Bul~    39 1 [mal~ 3 [chi~  2 [yes]   150  \n6  3107     627. NA       5 [Mon~ 3 [Rom~     1 1 [mal~ 9 [oth~ NA          32.9\n# ... with 17 more variables: income <dbl>, aggregate <dbl>,\n#   aggr_ind_annual <dbl>, educ_completed <dbl>, grade_complete <dbl>,\n#   grade_all <dbl>, unemployed <dbl>, reason_OLF <dbl>, sector <dbl>,\n#   occupation <dbl>, earn_mont <dbl>, earn_ann <dbl>, hours_week <dbl>,\n#   hours_mnt <dbl>, fulltime <dbl>, hhexp <dbl>, legacy_pension_amt <dbl>, and\n#   abbreviated variable names 1: ethnicity_head, 2: relation, 3: income_mnt\n```\n:::\n:::\n\n\n\n-   fichier SPSS\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemo <- foreign::read.spss(\"data/demo.sav\", to.data.frame = T)\nhead(demo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  age       marital address income     inccat  car     carcat         ed employ\n1  55     Marrié(e)      12     72  $50 - $74 36.2       Luxe Inf au Bac     23\n2  56 Non marrié(e)      29    153 $75 - $124 76.9       Luxe Inf au Bac     35\n3  28     Marrié(e)       9     28  $25 - $49 13.7 Economique     Bac +2      4\n4  24     Marrié(e)       4     26  $25 - $49 12.5 Economique   Bac +3/4      0\n5  25 Non marrié(e)       2     23  Inf à $25 11.3 Economique Niveau Bac      5\n6  45     Marrié(e)       9     76 $75 - $124 37.2       Luxe     Bac +2     13\n  retire     empcat           jobsat gender reside wireless multline voice\n1    Non     6 à 10   Très satisfait  Femme      4      Non      Non   Oui\n2    Non     6 à 10        Satisfait  Homme      1      Oui      Non   Oui\n3    Non Moins de 2           Neutre  Femme      3      Oui      Non   Oui\n4    Non Moins de 2 Très insatisfait  Homme      3      Oui      Oui   Oui\n5    Non      2 à 5      Insatistait  Homme      2      Non      Non   Non\n6    Non      2 à 5      Insatistait  Homme      2      Non      Oui   Oui\n  pager internet callid callwait owntv ownvcr owncd ownpda ownpc ownfax news\n1   Non    Aucun    Non      Non   Oui    Oui   Oui    Non   Non    Non  Non\n2   Oui    Aucun    Oui      Oui   Oui    Oui   Oui    Non   Non    Non  Non\n3   Non    Aucun    Oui      Oui   Oui    Oui   Oui    Oui   Oui    Non  Oui\n4   Non    Aucun    Non      Oui   Oui    Oui   Oui    Oui   Oui    Oui  Oui\n5   Non    Aucun    Oui      Non   Oui    Oui   Oui    Non   Non    Non  Oui\n6   Oui    Aucun    Non      Non   Oui    Oui   Oui    Non   Oui    Non  Non\n  response\n1      Non\n2      Oui\n3      Non\n4      Non\n5      Non\n6      Non\n```\n:::\n:::\n\n\n\nL'argument `to.data.frame = T` permet de retourner le résultat sous forme de dataframe.\n\n## Importer les données d'une base de données\n\nR peut interfacer avec différents systèmes de gestion de bases de données comme MS SQL Server, PostgreSQL, SQLite, MariaDB, etc. Nous allons utiliser les packages `DBI` et `RSQLite`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\nlibrary(RSQLite)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: le package 'RSQLite' a été compilé avec la version R 4.2.3\n```\n:::\n:::\n\n\n\nDans le cadre de cet exemple, nous allons utiliser une base de données nommée db.sqlite qui est en fait unee copie du dataframe `iris`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconnexion <- DBI::dbConnect(RSQLite::SQLite(), dbname = \"data/db.sqlite\")\ndbWriteTable(connexion, \"iris_info\", iris)\n```\n:::\n\n\n\nLorsqu'on veut travailler avec une base de données, la premère de chose consiste à établir une connexion avec celle-ci. Ceci est réalisée avec l'aide de la fonction `dbConnect()` de `DBI`. Nous stockons cette connexion dans l'objet nommé `connexion` que nous pouvons utiliser pour exploiter la base.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconnexion <- dbConnect(SQLite(), dbname = \"data/db.sqlite\")\n```\n:::\n\n\n\n-   Afficher les tables de la base de données\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(connexion)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"iris_info\"\n```\n:::\n:::\n\n\n\n-   Afficher les champs (variables) de la table `iris_info`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListFields(conn = connexion, \"iris_info\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n```\n:::\n:::\n\n\n\n-   Lire le contenu d'une table\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris_info <- dbReadTable(conn = connexion, \"iris_info\")\nhead(iris_info)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n:::\n:::\n\n\n\nNous pouvons aussi envoyer une requête SQL directement à la base et récupérer le résultat :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquery = \"\n  SELECT *\n  FROM iris_info\n  WHERE Species = 'versicolor'\n\"\n\nres <- dbGetQuery(conn = connexion, query)\nhead(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1          7.0         3.2          4.7         1.4 versicolor\n2          6.4         3.2          4.5         1.5 versicolor\n3          6.9         3.1          4.9         1.5 versicolor\n4          5.5         2.3          4.0         1.3 versicolor\n5          6.5         2.8          4.6         1.5 versicolor\n6          5.7         2.8          4.5         1.3 versicolor\n```\n:::\n:::\n\n\n\nLa dernière chose à faire lorsqu'on a fini de travailler avec une base de données c'est de se déconnecter avec la commande `dbDisconnect()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbDisconnect(connexion)\n```\n:::\n\n\n\n## Importer les données du web\n\nAccéder aux données issues du web fait partie de ce qu'on appelle le web scraping. Il s'agit d'un vaste domaine qui exige des connaissances de diverse technologies utlilisées pour distribuer du contenu dans le web (comme HTML, XML ou JSON). Dans ce qui suit, nous allons juste introduire quelques fonctions permettant de lire des fichiers texte, csv ou excel stockés dans le web et des tableaux HTML.\n\n-   Importer un fichier CSV\n\nLa forme la plus simple d'obtenir les données en ligne est d'importer les données stockées comme des fichiers texte, csv ou excel. Dans cet exemple, nous utilisons l'URL d'un fichier CSV sur le site GitHub : https://raw.githubusercontent.com/mwaskom/seaborn-data/master/diamonds.csv. Nous utilisons la fonction read.csv() pour importer le fichier CSV et le stocker dans un dataframe appelé df. Enfin, nous affichons les premières lignes du dataframe avec la fonction head().\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# spécifier l'URL du fichier CSV à importer\nurl <- \"https://raw.githubusercontent.com/mwaskom/seaborn-data/master/diamonds.csv\"\n\n# importer le fichier CSV en tant que dataframe\nlibrary(readr)\ndf <- read_csv(url)\n\n# afficher les premières lignes du dataframe\nhead(df)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 10\n  carat cut       color clarity depth table price     x     y     z\n  <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n```\n:::\n:::\n\n\n\n-   Importer une table HTML avec rvest\n\ne package rvest est une extension de R qui permet de récupérer des données à partir de pages web. C'est une bibliothèque d'outils pour le web scraping, qui permet de collecter des données structurées et non structurées à partir de sites HTML et de les transformer en formats utilisables. Le package est conçu pour manipuler des pages web en utilisant la syntaxe de R, facilitant ainsi l'extraction sélective de données.\n\nDans cet exemple, vous allez voir comment récupérer du texte et un tableau de données à partir de wikipedia.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rvest)\n\nurl <- \"https://fr.wikipedia.org/wiki/Liste_des_pays_par_population\"\n\npage <- read_html(url)\n```\n:::\n\n\n\nLa commande `html_elements()` permet de sélectionner un élément précis. Ici, vous sélectionnez une table. Ensuite vous précisez la table que vous vous, ici la première. Nous verons par la suite l'utilisation du pipe (`%>%`) du package `magrittr`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magrittr)\n\ntabs <- page %>% \n  html_elements(\"table\")\n\n#length(tabs)\n\ntab1 <- tabs[[1]]\n```\n:::\n\n\n\nVous utlisez alors la commande `html_table()` pour extraire la table sous forme de data.frame/tibble.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_table1 <- tab1 %>% \n  html_table()\n\nhead(df_table1)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 4\n  `Rang (2021)` `Pays ou territoire` `Population au 1er juillet 2021` Projecti~1\n  <chr>         <chr>                <chr>                            <chr>     \n1 -             Monde                7 975 105 156                    8 008 551~\n2 1             Chine[a]             1 425 893 465                    1 425 849~\n3 2             Inde                 1 407 563 842                    1 422 026~\n4 3             États-Unis[b]        336 997 624                      339 080 2~\n5 4             Indonésie            273 753 191                      276 386 3~\n6 5             Pakistan             231 402 117                      238 126 1~\n# ... with abbreviated variable name\n#   1: `Projection projetée au 1er janvier 2023`\n```\n:::\n:::\n\n\n\nLe code suivant permet de mettre en forme les données (arranger les noms de variables et transformer les chaînes de caractères en valeurs numériques).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(stringi)\n\ndf_table1 <- janitor::clean_names(df_table1)\n\ndf_table1 %>% \n  mutate(\n    population_au_1er_juillet_2021 = as.numeric(\n      stri_replace_all_charclass(population_au_1er_juillet_2021, \"\\\\p{WHITE_SPACE}\", \"\")\n    ),\n    projection_projetee_au_1er_janvier_2023 = as.numeric(\n      stri_replace_all_charclass(projection_projetee_au_1er_janvier_2023, \"\\\\p{WHITE_SPACE}\", \"\")\n    )\n  )\n```\n:::\n\n\n\n\nDe façon similaire vous pouvez récupérer du texte :\n\nCe code permet de récupérer le troisième paragraphe à partir de cette page web.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntexts <- page %>% \n  html_elements(\"p\")\n\n\ntexts_3 <- texts[[3]]\n\ntext2 <- texts_3 %>% \n  html_text2()\n\ntext2  \n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Certains territoires non souverains sont indiqués, en italique : les territoires habités de la France d'outre-mer (y compris les DROM), les territoires britanniques d'outre-mer habités et les dépendances de la Couronne, les territoires des États-Unis, les pays constitutifs non métropolitains du royaume des Pays-Bas et du royaume de Danemark, les Pays-Bas caribéens, les régions administratives spéciales de Chine et Tokelau (territoire dépendant de la Nouvelle-Zélande). Ils ne sont ici pas comptés dans la population de l'État souverain dont ils dépendent. La population de certains États non reconnus internationalement est comptée avec celle du pays dont ils font partie selon l'ONU.\"\n```\n:::\n:::\n\n\n\n\n## Exporter les données\n\nR permet d'exporter les données vers certains logiciels comme Excel, SPSS, Stata et SAS.\n\n-   `write_csv`, `write_csv2`, `read_tsv` du package \\`readr\\`\\` permettent d'enregistrer un tableau ou un tibble dans un fichier au format texte délimité\n\n-   `write_sas`, `write_sav` et `write_dta` du package `haven` permettent d'enregistrer un tableau de données respectivement vers SAS, SPSS et Stata.\n\n-   `write.xlsx` du package `xlxs` permet d'exporter vers Excel.\n\nDans tous les cas, le premier argument est le nom de l'objet contenant les données et le deuxième correspond à une chaîne de caractère contenant le nom et l'extension du fichier de sortie. Un exemple d'export vers excel est donnné ci-après.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxlsx::write.xlsx(objet_r, file = \"data/nom_du_fichier.xlsx\")\n```\n:::\n\n\n\nR permet aussi d'enregistrer tout type d'objet dans un fichier de format `Rdata`. C'est un format propre à R et peut stocker plusieurs objets en son sein.\n\nLa commande suivante permet d'enregistrer les objets `X1` et `df` dans un fichier nommé `fiche_1`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsave(X1, df, file = \"fiche_1.RData\")\n```\n:::\n\n\n\nPour charger ces objets lors d'une session, vous pouvez la focntion `load()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(\"fiche_1.RData\")\n```\n:::\n\n\n\nLe seul problème avec `load()` est qu'il importe les objets avec leur nom d'origine. Si la session contient déjà d'autres objets, ceux-ci seront écrasés.\n\nLa solution est d'utiliser les fonctions `saveRDS()` et `readRDS()`, qui permettent d'enregistrer un unique objet, et de le charger dans notre session avec le nom que l'on souhaite.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(df, file = \"fiche_1.rds\")\ndf <- readRDS(\"fiche_1.rds\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}