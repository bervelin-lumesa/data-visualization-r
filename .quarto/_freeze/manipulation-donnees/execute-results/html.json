{
  "hash": "c6fe872407183eed9ff329cc84b36d7d",
  "result": {
    "markdown": "# Manipulation de donn√©es\n\nLa manipulation de donn√©es est l'une des comp√©tences les plus importantes en science des donn√©es, car elle permet de nettoyer, transformer et regrouper des donn√©es brutes en des ensembles de donn√©es utiles et informatifs. R est un langage de programmation populaire pour la science des donn√©es qui offre une grande vari√©t√© de fonctions et de packages pour effectuer ces t√¢ches. De la s√©lection de colonnes sp√©cifiques √† la transformation de donn√©es en utilisant des fonctions personnalis√©es, en passant par la fusion de ensembles de donn√©es diff√©rents, la manipulation de donn√©es avec R est un art qui n√©cessite une bonne compr√©hension des outils adapt√©s. Dans ce chapitre, nous allons explorer les techniques de la manipulation de donn√©es avec R et quelques packages dont principalement `dplyr`.\n\n## Introduction au pipe (`%>%`)\n\nQuand on manipule un tableau de donn√©es, il est tr√®s fr√©quent d'encha√Æner plusieurs op√©rations. On va par exemple extraire une sous-population avec `filter`, s√©lectionner des colonnes avec `select` puis trier selon une variable avec `arrange`, etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ncounties <- readRDS(\"data/counties.rds\")\n```\n:::\n\n\nTRaditionnellement, nous pouvons √©crire ceci :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(\n  ungroup(\n  slice_max(\n  summarize(\n    group_by(counties, state, metro), \n    total_pop = sum(population)),\n  total_pop, n = 1)), \n  metro)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'state'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 √ó 2\n  metro        n\n  <chr>    <int>\n1 Metro       44\n2 Nonmetro     6\n```\n:::\n:::\n\n\nPour simplifier et am√©liorer la lisibilit√© du code, on va utiliser un op√©rateur, pipe. Le pipe se note `%>%`, et son fonctionnement est le suivant : si j'ex√©cute expr `%>%` f, alors le r√©sultat de l'expression expr, √† gauche du pipe, sera pass√© comme premier argument √† la fonction f, √† droite du pipe, ce qui revient √† ex√©cuter `f(expr)`.\n\nAinsi le premier code peut s'\"crire comme suit, en utilisant le pipe :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>%\n  group_by(state, metro) %>%\n  summarize(total_pop = sum(population)) %>%\n  slice_max(total_pop, n = 1) %>%\n  ungroup() %>%\n  count(metro)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'state'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 √ó 2\n  metro        n\n  <chr>    <int>\n1 Metro       44\n2 Nonmetro     6\n```\n:::\n:::\n\n\nOn voit bien ce code est plus clair, car les op√©rations sont √©crites dans l'ordre naturelle.\n\nLes donn√©es (`counties`) que nous allons utiliser contiennent les comt√©s des diff√©rents Etats aux USA avec des diff√©rents indicateurs.\n\n## Les verbes de dplyr\n\nManipuler les donn√©es avec dplyr se fait au moyen d'un certain nombre de verbes qui indique l'action √† ex√©cuter le tableau de donn√©es (data.frame/tibble). Toutes les fonctions que nous verons prennent un dataframe en entr√©e et retourne √©galement un datafrme.\n\n### select\n\nPermet de s√©lectionner une ou plusieurs colonnes d'un tableau de donn√©e.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>%\n  # Selectionner 4 colonnes\n  select(state, county, population, poverty)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 √ó 4\n   state   county   population poverty\n   <chr>   <chr>         <dbl>   <dbl>\n 1 Alabama Autauga       55221    12.9\n 2 Alabama Baldwin      195121    13.4\n 3 Alabama Barbour       26932    26.7\n 4 Alabama Bibb          22604    16.8\n 5 Alabama Blount        57710    16.7\n 6 Alabama Bullock       10678    24.6\n 7 Alabama Butler        20354    25.4\n 8 Alabama Calhoun      116648    20.5\n 9 Alabama Chambers      34079    21.6\n10 Alabama Cherokee      26008    19.2\n# ‚Ä¶ with 3,128 more rows\n```\n:::\n:::\n\n\nLes `:` permettent de s√©lectionner des colonnes qui se suivent.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  select(metro : black)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 √ó 7\n   metro    population   men women hispanic white black\n   <chr>         <dbl> <dbl> <dbl>    <dbl> <dbl> <dbl>\n 1 Metro         55221 26745 28476      2.6  75.8  18.5\n 2 Metro        195121 95314 99807      4.5  83.1   9.5\n 3 Nonmetro      26932 14497 12435      4.6  46.2  46.7\n 4 Metro         22604 12073 10531      2.2  74.5  21.4\n 5 Metro         57710 28512 29198      8.6  87.9   1.5\n 6 Nonmetro      10678  5660  5018      4.4  22.2  70.7\n 7 Nonmetro      20354  9502 10852      1.2  53.3  43.8\n 8 Metro        116648 56274 60374      3.5  73    20.3\n 9 Nonmetro      34079 16258 17821      0.4  57.3  40.3\n10 Nonmetro      26008 12975 13033      1.5  91.7   4.8\n# ‚Ä¶ with 3,128 more rows\n```\n:::\n:::\n\n\nLa commande suivante permet de s√©lectionner les colonnes dont les noms commencent avec \"in\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  select(starts_with(\"in\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 √ó 4\n   income income_err income_per_cap income_per_cap_err\n    <dbl>      <dbl>          <dbl>              <dbl>\n 1  51281       2391          24974               1080\n 2  50254       1263          27317                711\n 3  32964       2973          16824                798\n 4  38678       3995          18431               1618\n 5  45813       3141          20532                708\n 6  31938       5884          17580               2055\n 7  32229       1793          18390                714\n 8  41703        925          21374                489\n 9  34177       2949          21071               1366\n10  36296       1710          21811               1556\n# ‚Ä¶ with 3,128 more rows\n```\n:::\n:::\n\n\nOn peut aussi utiliser `contains()` ou `ends_with()` pour s√©lectionner respectivement les colonnes qui contiennent ou se se terminent par une cha√Æne de caract√®re donn√©e. Des colonnes peuvent √™tre exclues du r√©sultat par le signe (-). On peut par exemple exclure les 6 premi√®res colonnes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  select(-c(1 : 6))\n```\n:::\n\n\nüëâ S√©lectionnez les colonnes dont les noms se terminent par \"tion\". Le r√©sultat devrait ressembler √† √ßa :\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 √ó 3\n   population construction production\n        <dbl>        <dbl>      <dbl>\n 1      55221          8.6       17.1\n 2     195121         10.8       11.2\n 3      26932         10.8       23.1\n 4      22604         19         23.7\n 5      57710         13.5       19.9\n 6      10678         20.1       26.4\n 7      20354         10.3       23.7\n 8     116648         10.5       20.4\n 9      34079         11.5       24.4\n10      26008         13.7       21.5\n# ‚Ä¶ with 3,128 more rows\n```\n:::\n:::\n\n\n### arrange\n\nPermet de trier une colonne selon un ordre donn√©.\n\nPar d√©faut, `arrange()` trie le r√©sultat par ordre croissant.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected <- counties %>%\n  select(region, state, county, public_work, population, private_work, women, citizens, work_at_home, walk, land_area)\n\ncounties_selected %>%\n  arrange(public_work)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 √ó 11\n   region      state county publi‚Ä¶¬π popul‚Ä¶¬≤ priva‚Ä¶¬≥  women citiz‚Ä¶‚Å¥ work_‚Ä¶‚Åµ  walk\n   <chr>       <chr> <chr>    <dbl>   <dbl>   <dbl>  <dbl>   <dbl>   <dbl> <dbl>\n 1 North Cent‚Ä¶ Ohio  Holmes     5.8   43436    81.3  21690   28871     8.9   6.9\n 2 North Cent‚Ä¶ Nebr‚Ä¶ McPhe‚Ä¶     5.9     433    69.4    210     341    22.6  15.7\n 3 North Cent‚Ä¶ Indi‚Ä¶ LaGra‚Ä¶     6.6   38084    84.1  18851   24533     6.1   2.9\n 4 North Cent‚Ä¶ Indi‚Ä¶ Kosci‚Ä¶     6.9   77983    88.3  39113   56795     3.8   2.1\n 5 North Cent‚Ä¶ Indi‚Ä¶ Spenc‚Ä¶     6.9   20856    86.3  10299   15889     3.6   1.2\n 6 North Cent‚Ä¶ Nebr‚Ä¶ Dakota     7.3   20798    87.3  10698   12585     2.5   1.9\n 7 North Cent‚Ä¶ Illi‚Ä¶ Jersey     7.5   22625    86.6  11567   17534     3.8   3.3\n 8 North Cent‚Ä¶ Indi‚Ä¶ Clint‚Ä¶     7.5   32835    87.5  16670   22754     2.9   1.1\n 9 North Cent‚Ä¶ Indi‚Ä¶ Barth‚Ä¶     7.6   79488    87.8  39954   55362     2.2   1.6\n10 North Cent‚Ä¶ Indi‚Ä¶ Elkha‚Ä¶     7.7  200685    87.5 101510  132834     2.9   1.6\n# ‚Ä¶ with 3,128 more rows, 1 more variable: land_area <dbl>, and abbreviated\n#   variable names ¬π‚Äãpublic_work, ¬≤‚Äãpopulation, ¬≥‚Äãprivate_work, ‚Å¥‚Äãcitizens,\n#   ‚Åµ‚Äãwork_at_home\n```\n:::\n:::\n\n\nOn peut obtenir le r√©sultat par ordre d√©croissant avec la fonction `desc()` comme suit :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  # trier par ordre d√©croissant de 'public_work'\n  arrange(desc(public_work))\n```\n:::\n\n\nüëâ Quelle est la comt√© avec la plus grande population et celle avec la petite populaion?\n\n\n\n\n\n\n\n### filter\n\nPermet de s√©lectionner des lignes d'un dataframe selon une ou plusieurs conditions.\n\nLa commande suivante permet de filtrer les comt√©s ayant une population sup√©rieure √† 1000000.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  # filtrer les comt√©s avec une population sup √† 1000000\n  filter(population > 1000000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 41 √ó 11\n   region state      county publi‚Ä¶¬π popul‚Ä¶¬≤ priva‚Ä¶¬≥  women citiz‚Ä¶‚Å¥ work_‚Ä¶‚Åµ  walk\n   <chr>  <chr>      <chr>    <dbl>   <dbl>   <dbl>  <dbl>   <dbl>   <dbl> <dbl>\n 1 West   Arizona    Maric‚Ä¶    11.7  4.02e6    82.5 2.03e6 2659853     5.9   1.6\n 2 West   California Alame‚Ä¶    13.8  1.58e6    78.7 8.08e5 1025865     5.6   3.7\n 3 West   California Contr‚Ä¶    13.6  1.10e6    77.5 5.61e5  720881     5.8   1.7\n 4 West   California Los A‚Ä¶    11.5  1.00e7    79   5.09e6 6046749     5.1   2.8\n 5 West   California Orange    10.2  3.12e6    81.8 1.58e6 1961585     5.2   2  \n 6 West   California River‚Ä¶    14.9  2.30e6    77.1 1.15e6 1427761     5.2   1.4\n 7 West   California Sacra‚Ä¶    21.8  1.47e6    70.8 7.49e5  985653     5.1   2.2\n 8 West   California San B‚Ä¶    16.7  2.09e6    76.4 1.05e6 1292879     4.2   1.8\n 9 West   California San D‚Ä¶    14.8  3.22e6    77.3 1.60e6 2141755     6.8   2.9\n10 West   California Santa‚Ä¶     9.3  1.87e6    84.3 9.29e5 1131378     4.6   2  \n# ‚Ä¶ with 31 more rows, 1 more variable: land_area <dbl>, and abbreviated\n#   variable names ¬π‚Äãpublic_work, ¬≤‚Äãpopulation, ¬≥‚Äãprivate_work, ‚Å¥‚Äãcitizens,\n#   ‚Åµ‚Äãwork_at_home\n```\n:::\n:::\n\n\nOn peut combiner plusieurs conditions avec des op√©rateurs(\\| pour OU, & et ',' pour ET, == pour l'√©galit√©).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  # filtrer les comt√©s avec une population sup √† 1000000 √† California\n  filter(population > 1000000, state == \"California\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 √ó 11\n  region state      county  publi‚Ä¶¬π popul‚Ä¶¬≤ priva‚Ä¶¬≥  women citiz‚Ä¶‚Å¥ work_‚Ä¶‚Åµ  walk\n  <chr>  <chr>      <chr>     <dbl>   <dbl>   <dbl>  <dbl>   <dbl>   <dbl> <dbl>\n1 West   California Alameda    13.8  1.58e6    78.7 8.08e5 1025865     5.6   3.7\n2 West   California Contra‚Ä¶    13.6  1.10e6    77.5 5.61e5  720881     5.8   1.7\n3 West   California Los An‚Ä¶    11.5  1.00e7    79   5.09e6 6046749     5.1   2.8\n4 West   California Orange     10.2  3.12e6    81.8 1.58e6 1961585     5.2   2  \n5 West   California Rivers‚Ä¶    14.9  2.30e6    77.1 1.15e6 1427761     5.2   1.4\n6 West   California Sacram‚Ä¶    21.8  1.47e6    70.8 7.49e5  985653     5.1   2.2\n7 West   California San Be‚Ä¶    16.7  2.09e6    76.4 1.05e6 1292879     4.2   1.8\n8 West   California San Di‚Ä¶    14.8  3.22e6    77.3 1.60e6 2141755     6.8   2.9\n9 West   California Santa ‚Ä¶     9.3  1.87e6    84.3 9.29e5 1131378     4.6   2  \n# ‚Ä¶ with 1 more variable: land_area <dbl>, and abbreviated variable names\n#   ¬π‚Äãpublic_work, ¬≤‚Äãpopulation, ¬≥‚Äãprivate_work, ‚Å¥‚Äãcitizens, ‚Åµ‚Äãwork_at_home\n```\n:::\n:::\n\n\nPlusieurs verbes peuvent √™tre encha√Æn√©s avec le pipe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  filter(state == \"Texas\", population > 10000) %>%\n  arrange(desc(private_work))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 169 √ó 11\n   region state county  public_work popul‚Ä¶¬π priva‚Ä¶¬≤  women citiz‚Ä¶¬≥ work_‚Ä¶‚Å¥  walk\n   <chr>  <chr> <chr>         <dbl>   <dbl>   <dbl>  <dbl>   <dbl>   <dbl> <dbl>\n 1 South  Texas Gregg           9.8  123178    84.7 6.28e4   84342     2.1   1.6\n 2 South  Texas Collin         10    862215    84.1 4.39e5  548008     7.8   0.8\n 3 South  Texas Dallas          9.5 2485003    83.9 1.26e6 1432702     4.1   1.5\n 4 South  Texas Harris         10.1 4356362    83.4 2.19e6 2494733     3.3   1.5\n 5 South  Texas Andrews         9.6   16775    83.1 8.22e3   10207     2.5   0.1\n 6 South  Texas Tarrant        11.4 1914526    83.1 9.77e5 1219370     3.9   1.2\n 7 South  Texas Titus          10     32553    82.5 1.65e4   18834     1.8   1  \n 8 South  Texas Denton         11.9  731851    82.2 3.72e5  482962     6.2   1.2\n 9 South  Texas Ector          11.2  149557    82   7.44e4   92579     2.1   1.1\n10 South  Texas Moore          11.7   22281    82   1.08e4   11050     1.6   1.7\n# ‚Ä¶ with 159 more rows, 1 more variable: land_area <dbl>, and abbreviated\n#   variable names ¬π‚Äãpopulation, ¬≤‚Äãprivate_work, ¬≥‚Äãcitizens, ‚Å¥‚Äãwork_at_home\n```\n:::\n:::\n\n\n### mutate\n\nPermet d'ajouter une nouvelle variable dans le dataframe. Elle est souvent utiliser pour cr√©er une variable √† partir sur base d'un calcul.\n\nLa commande suivante permet cr√©er une variable qui contient le nombre d'employ√©s du secteur public `public_workers` √† partir de `population` et `public_work`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  mutate(public_workers = population * public_work / 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 √ó 12\n   region state   county   public_‚Ä¶¬π popul‚Ä¶¬≤ priva‚Ä¶¬≥ women citiz‚Ä¶‚Å¥ work_‚Ä¶‚Åµ  walk\n   <chr>  <chr>   <chr>        <dbl>   <dbl>   <dbl> <dbl>   <dbl>   <dbl> <dbl>\n 1 South  Alabama Autauga       20.9   55221    73.6 28476   40725     1.8   0.5\n 2 South  Alabama Baldwin       12.3  195121    81.5 99807  147695     3.9   1  \n 3 South  Alabama Barbour       20.8   26932    71.8 12435   20714     1.6   1.8\n 4 South  Alabama Bibb          16.1   22604    76.8 10531   17495     0.7   0.6\n 5 South  Alabama Blount        13.5   57710    82   29198   42345     2.3   0.9\n 6 South  Alabama Bullock       15.1   10678    79.5  5018    8057     2.8   5  \n 7 South  Alabama Butler        16.2   20354    77.4 10852   15581     1.7   0.8\n 8 South  Alabama Calhoun       20.8  116648    74.1 60374   88612     2.7   1.2\n 9 South  Alabama Chambers      12.1   34079    85.1 17821   26462     2.1   0.3\n10 South  Alabama Cherokee      18.5   26008    73.1 13033   20600     2.5   0.6\n# ‚Ä¶ with 3,128 more rows, 2 more variables: land_area <dbl>,\n#   public_workers <dbl>, and abbreviated variable names ¬π‚Äãpublic_work,\n#   ¬≤‚Äãpopulation, ¬≥‚Äãprivate_work, ‚Å¥‚Äãcitizens, ‚Åµ‚Äãwork_at_home\n```\n:::\n:::\n\n\nOn peut savoir la comt√© avec le plus grand nombre de d'employ√©s du secteur public.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  mutate(public_workers = public_work * population / 100) %>%\n  arrange(desc(public_workers)) %>% \n  select(state, county, public_workers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 √ó 3\n   state      county         public_workers\n   <chr>      <chr>                   <dbl>\n 1 California Los Angeles          1154415.\n 2 Illinois   Cook                  602185.\n 3 California San Diego             477018.\n 4 Arizona    Maricopa              470123.\n 5 Texas      Harris                439993.\n 6 New York   Kings                 373717.\n 7 California San Bernardino        349826.\n 8 California Riverside             342407.\n 9 California Sacramento            319551.\n10 California Orange                317839.\n# ‚Ä¶ with 3,128 more rows\n```\n:::\n:::\n\n\nüëâ Quelles sont les 5 comt√©s ayant la plus grande proportion des femmes ?\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 √ó 3\n  state       county        proportion_women\n  <chr>       <chr>                    <dbl>\n1 Virginia    Norton city              0.594\n2 Georgia     Pulaski                  0.580\n3 Alabama     Sumter                   0.557\n4 Mississippi Sharkey                  0.555\n5 Virginia    Franklin city            0.555\n```\n:::\n:::\n\n\n### count\n\nPermet de compter le nombre d'occurrence de valeurs d'une variable qualitative.\n\nLe code suivant permet de compter le nombre de comt√©s dans chaque region.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>% \n  count(region, sort = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 √ó 2\n  region            n\n  <chr>         <int>\n1 South          1420\n2 North Central  1054\n3 West            447\n4 Northeast       217\n```\n:::\n:::\n\n\n`count()` dispose d'un argument `wt` qui permet de fournir une variable quantitative pour effectuer la somme. La commande suivante calcule la somme de la variable `citizens` pour chaque region.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>% \n  count(region, wt = citizens, sort = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 √ó 2\n  region               n\n  <chr>            <dbl>\n1 South         83019572\n2 North Central 49472719\n3 West          49415038\n4 Northeast     40058582\n```\n:::\n:::\n\n\nLe nombre de personnes qui travaillent √† la maison dans chaque √©tat √™tre obtenu avec la commande suivante :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>% \n  mutate(pop_work_at_home = population * work_at_home / 100) %>% \n  count(state, wt = pop_work_at_home, sort = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 √ó 2\n   state                 n\n   <chr>             <dbl>\n 1 California     2026868.\n 2 Texas          1070728.\n 3 Florida        1006787.\n 4 New York        762667.\n 5 Illinois        539101.\n 6 Pennsylvania    505435.\n 7 Georgia         470379.\n 8 North Carolina  446695.\n 9 Ohio            405370.\n10 Washington      380857.\n# ‚Ä¶ with 40 more rows\n```\n:::\n:::\n\n\nüëâ Calculer le nombre de personnes qui font la marche pour se rendre au travail.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 √ó 2\n   state                n\n   <chr>            <dbl>\n 1 New York      1237938.\n 2 California    1017964.\n 3 Pennsylvania   505397.\n 4 Texas          430783.\n 5 Illinois       400346.\n 6 Massachusetts  316765.\n 7 Florida        284723.\n 8 New Jersey     273047.\n 9 Ohio           266911.\n10 Washington     239764.\n# ‚Ä¶ with 40 more rows\n```\n:::\n:::\n\n\n### summarize\n\nPermet de calculer un sommaire sur une variable quantitative. Exp: moyenne, √©cart-type\n\nLa commande suivante compte le nombre d'observations dans le tableau de donn√©es.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>% \n  summarise(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 √ó 1\n      n\n  <int>\n1  3138\n```\n:::\n:::\n\n\nNous pouvons calcaler plusieurs statistiques telles que la moyenne, minimum, √©cart-type et autres comme sur la commande suivante :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>% \n  summarise(\n    # calcule le minimum\n    min_population = min(population),\n    # calcule la moyenne\n    mean_population = mean(population),\n    # calcule le maximum\n    max_population = max(population)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 √ó 3\n  min_population mean_population max_population\n           <dbl>           <dbl>          <dbl>\n1             85         100652.       10038388\n```\n:::\n:::\n\n\n### group_by() / ungroup()\n\nPermet de grouper un dataframe en fonction d'une variable qualitative. Cela permet d'effectuer des op√©rations sur ce groupe.\n\nLe groupe n'a de valeur que lorsqu'il est combin√© avec d'autres verbes. Des exemples sont fournis ci-apr√®s :\n\n-   Calculer pour chaque Etat, la superficie et la population totale.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  # Group by state \n  group_by(state) %>%\n  # Find the total area and population\n  summarise(\n    total_area = sum(land_area),\n    total_population = sum(population)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 √ó 3\n   state       total_area total_population\n   <chr>            <dbl>            <dbl>\n 1 Alabama         50645.          4830620\n 2 Alaska         553560.           725461\n 3 Arizona        113594.          6641928\n 4 Arkansas        52035.          2958208\n 5 California     155779.         38421464\n 6 Colorado       103642.          5278906\n 7 Connecticut      4842.          3593222\n 8 Delaware         1949.           926454\n 9 Florida         53625.         19645772\n10 Georgia         57514.         10006693\n# ‚Ä¶ with 40 more rows\n```\n:::\n:::\n\n\nOn peut ajouter des verbes √† la commande pr√©c√©dente pour calculer la densit√© et la trier par ordre d√©croissant.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected %>%\n  group_by(state) %>%\n  summarize(total_area = sum(land_area),\n            total_population = sum(population)) %>%\n  mutate(density = total_population / total_area) %>%\n  arrange(desc(density))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 √ó 4\n   state         total_area total_population density\n   <chr>              <dbl>            <dbl>   <dbl>\n 1 New Jersey         7354.          8904413   1211.\n 2 Rhode Island       1034.          1053661   1019.\n 3 Massachusetts      7800.          6705586    860.\n 4 Connecticut        4842.          3593222    742.\n 5 Maryland           9707.          5930538    611.\n 6 Delaware           1949.           926454    475.\n 7 New York          47126.         19673174    417.\n 8 Florida           53625.         19645772    366.\n 9 Pennsylvania      44743.         12779559    286.\n10 Ohio              40861.         11575977    283.\n# ‚Ä¶ with 40 more rows\n```\n:::\n:::\n\n\n-   L'Etat avec le plus faible revenu dans chaque region\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected <- counties %>%\n  select(region, state, county, population, income)\n\ncounties_selected %>%\n  group_by(region, state) %>%\n  # Calculate average income\n  summarise(average_income = mean(income)) %>%\n  # Find the lowest income state in each region\n  slice_min(average_income, n = 1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'region'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 √ó 3\n# Groups:   region [4]\n  region        state       average_income\n  <chr>         <chr>                <dbl>\n1 North Central Missouri            41755.\n2 Northeast     Maine               46142.\n3 South         Mississippi         34939.\n4 West          New Mexico          40184.\n```\n:::\n:::\n\n\n-   Deux Etats avec le taux de pauvret√© le plus √©lev√© dans chaque region\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  group_by(region, state) %>% \n  summarise(average_poverty = mean(poverty)) %>% \n  slice_max(average_poverty, n = 2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'region'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 √ó 3\n# Groups:   region [4]\n  region        state       average_poverty\n  <chr>         <chr>                 <dbl>\n1 North Central Missouri               18.1\n2 North Central Michigan               16.7\n3 Northeast     Maine                  15.1\n4 Northeast     New York               14.5\n5 South         Mississippi            25.7\n6 South         Georgia                22.2\n7 West          Arizona                21.3\n8 West          New Mexico             21.1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>%\n  group_by(region) %>%\n  summarise(across(ends_with(\"tion\"), mean, .names = \"mean_{.col}\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 √ó 4\n  region        mean_population mean_construction mean_production\n  <chr>                   <dbl>             <dbl>           <dbl>\n1 North Central          64072.              12.1            17.4\n2 Northeast             258016.              10.0            13.3\n3 South                  83048.              13.1            16.4\n4 West                  166434.              14.5            11.7\n```\n:::\n:::\n\n\n### rename\n\nPermet de renommer le nom d'une colonne (variable). La syntaxe est la suivante : `rename(nouveau_nom = ancien_nom)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_selected <- counties %>%\n  select(census_id, region, state, county, population, income)\n\ncounties_selected %>% \n  rename(id = census_id, us_state = state)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 √ó 6\n   id    region us_state county   population income\n   <chr> <chr>  <chr>    <chr>         <dbl>  <dbl>\n 1 1001  South  Alabama  Autauga       55221  51281\n 2 1003  South  Alabama  Baldwin      195121  50254\n 3 1005  South  Alabama  Barbour       26932  32964\n 4 1007  South  Alabama  Bibb          22604  38678\n 5 1009  South  Alabama  Blount        57710  45813\n 6 1011  South  Alabama  Bullock       10678  31938\n 7 1013  South  Alabama  Butler        20354  32229\n 8 1015  South  Alabama  Calhoun      116648  41703\n 9 1017  South  Alabama  Chambers      34079  34177\n10 1019  South  Alabama  Cherokee      26008  36296\n# ‚Ä¶ with 3,128 more rows\n```\n:::\n:::\n\n\nSi l'on d√©sire ne garder que les colonnes r√©nomm√©es, on peut utiliser `select()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  select(id = census_id, us_state = state)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 √ó 2\n   id    us_state\n   <chr> <chr>   \n 1 1001  Alabama \n 2 1003  Alabama \n 3 1005  Alabama \n 4 1007  Alabama \n 5 1009  Alabama \n 6 1011  Alabama \n 7 1013  Alabama \n 8 1015  Alabama \n 9 1017  Alabama \n10 1019  Alabama \n# ‚Ä¶ with 3,128 more rows\n```\n:::\n:::\n\n\n### transmute\n\nPermet de s√©lectionner les colonnes et d'ajouter une colonne. Cette fonction combine donc les actions de `select` + `mutate`.\n\nLa commande suivante consiste √† calculer une nouvelle variable, √† s√©lectionner les varibles et √† trier selon nouvelle variable cr√©e√©.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  mutate(density = population / land_area) %>% \n  select(state, county, population, density) %>% \n  arrange(density)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 √ó 4\n   state      county                     population density\n   <chr>      <chr>                           <dbl>   <dbl>\n 1 Alaska     Yukon-Koyukuk Census Area        5644  0.0388\n 2 Alaska     Lake and Peninsula Borough       1474  0.0623\n 3 Alaska     Yakutat City and Borough          643  0.0841\n 4 Alaska     North Slope Borough              9667  0.109 \n 5 Alaska     Denali Borough                   2060  0.162 \n 6 Alaska     Northwest Arctic Borough         7732  0.217 \n 7 Montana    Garfield                         1047  0.224 \n 8 New Mexico Harding                           565  0.266 \n 9 Montana    Petroleum                         443  0.268 \n10 Alaska     Dillingham Census Area           4979  0.268 \n# ‚Ä¶ with 3,128 more rows\n```\n:::\n:::\n\n\nAvec `transmute()`, le code pr√©c√©dent est r√©duit comme suit :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>%\n  transmute(state, county, population, density = population / land_area) %>%\n  arrange(density)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 √ó 4\n   state      county                     population density\n   <chr>      <chr>                           <dbl>   <dbl>\n 1 Alaska     Yukon-Koyukuk Census Area        5644  0.0388\n 2 Alaska     Lake and Peninsula Borough       1474  0.0623\n 3 Alaska     Yakutat City and Borough          643  0.0841\n 4 Alaska     North Slope Borough              9667  0.109 \n 5 Alaska     Denali Borough                   2060  0.162 \n 6 Alaska     Northwest Arctic Borough         7732  0.217 \n 7 Montana    Garfield                         1047  0.224 \n 8 New Mexico Harding                           565  0.266 \n 9 Montana    Petroleum                         443  0.268 \n10 Alaska     Dillingham Census Area           4979  0.268 \n# ‚Ä¶ with 3,128 more rows\n```\n:::\n:::\n\n\n## Recodage de variables\n\nIl arrive souvent que nous voulions modifier les modalit√©s d'une varible ou cr√©er des classes √† partir d'une variable quantitative.\n\nS'il s'agit d'une condition simple, nous povons utiliser `ifelse()`. Pour des condtions longues, `cut()`, `recode()`, `case_when()` ferons l'affaire.\n\n### ifelse\n\nLa commande suivante permet de cr√©er une variable avec deux modalit√©s sur base de la variable population.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  mutate(population_group = ifelse(population > 25000, \">25000\", \"<=25000\")) %>% \n  select(population, population_group)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 √ó 2\n   population population_group\n        <dbl> <chr>           \n 1      55221 >25000          \n 2     195121 >25000          \n 3      26932 >25000          \n 4      22604 <=25000         \n 5      57710 >25000          \n 6      10678 <=25000         \n 7      20354 <=25000         \n 8     116648 >25000          \n 9      34079 >25000          \n10      26008 >25000          \n# ‚Ä¶ with 3,128 more rows\n```\n:::\n:::\n\n\n### recode\n\nAvec `recode()`, la syntaxe est la suivante : `recode(variable, \"ancienne_valeur\" = \"nouvelle_valeur\")`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  mutate(metro_new = recode(metro, \n                            \"Metro\" = \"Avec Metro\", \n                            \"Nonmetro\" = \"Sans metro\")) %>% \n  count(metro_new)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 √ó 2\n  metro_new      n\n  <chr>      <int>\n1 Avec Metro  1165\n2 Sans metro  1973\n```\n:::\n:::\n\n\n### case_when\n\n`case_when()` est une une g√©n√©ralisation du `ifelse()` au cas o√π nous avons plusieurs conditions √† v√©rifier. Nous pouvons cr√©er une variable cat√©gorielle √† partir de la variable quantitative.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  select(income) %>% \n  mutate(income_cat = case_when(\n    income >= 17000 & income <= 40000 ~ \"17000-40000\",\n    income > 40000 & income <= 46000 ~ \"40001-46000\",\n    income > 46000 & income <= 50000 ~ \"46001-50000\",\n    TRUE ~ \">50000\"\n  )) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 √ó 2\n   income income_cat \n    <dbl> <chr>      \n 1  51281 >50000     \n 2  50254 >50000     \n 3  32964 17000-40000\n 4  38678 17000-40000\n 5  45813 40001-46000\n 6  31938 17000-40000\n 7  32229 17000-40000\n 8  41703 40001-46000\n 9  34177 17000-40000\n10  36296 17000-40000\n# ‚Ä¶ with 3,128 more rows\n```\n:::\n:::\n\n\nLa clause TRUE \\~ \"\\>50000\" permet d'assigner une valeur √† toutes les lignes pour lesquelles aucune des conditions pr√©c√©dentes n'est vraie.\n\nLe m√™me r√©sultat peut √™tre obtenu avec `cut()`.\n\n### cut\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties %>% \n  select(income) %>% \n  mutate(\n    income_cat = cut(\n      income,\n      breaks = c(17000, 40000, 46000, 50000, 150000),\n      labels = c(\"17000-40000\", \"40001-46000\", \"46001-50000\", \">50000\")\n  ))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,138 √ó 2\n   income income_cat \n    <dbl> <fct>      \n 1  51281 >50000     \n 2  50254 >50000     \n 3  32964 17000-40000\n 4  38678 17000-40000\n 5  45813 40001-46000\n 6  31938 17000-40000\n 7  32229 17000-40000\n 8  41703 40001-46000\n 9  34177 17000-40000\n10  36296 17000-40000\n# ‚Ä¶ with 3,128 more rows\n```\n:::\n:::\n\n\nL'argument `include_lowest = T` peut √™tre ajout√© √† `cut()` pour inclure la valeur minimale dans la premi√®re classe.\n\n## Mettre les donn√©es en ordre (wide - long format)\n\nL'objectif de tidyr est de fournir des fonctions pour arranger ses donn√©es et les convertir dans un format tidy. Quand est-ce que les donn√©es sont dans un format tidy ?\n\nLe concept de tidy data repose sur trois r√®gles interd√©pendantes. Des donn√©es sont consid√©r√©es comme tidy si :\n\n1.  chaque ligne correspond √† une observation\n\n2.  chaque colonne correspond √† une variable\n\n3.  chaque valeur est pr√©sente dans une unique case de la table ou, de mani√®re √©quivalente, des unit√©s d'observations diff√©rentes sont pr√©sentes dans des tables diff√©rentes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncountry <- c(\"Belgium\", \"France\", \"Germany\", \"Italy\", \"Spain\", \"Switzerland\")\n`2002` <- c(10311970, 59925035, 82350671, 57926999, 40152517, 7361757)\n`2007` <- c(10392226, 61083916, 82400996, 58147733, 40448191, 7554661)\n\n(df <- tibble(\n  country,\n  `2002`,\n  `2007`\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 √ó 3\n  country       `2002`   `2007`\n  <chr>          <dbl>    <dbl>\n1 Belgium     10311970 10392226\n2 France      59925035 61083916\n3 Germany     82350671 82400996\n4 Italy       57926999 58147733\n5 Spain       40152517 40448191\n6 Switzerland  7361757  7554661\n```\n:::\n:::\n\n\n### pivot_longer : transformer des colonnes en lignes\n\nIci nous rassemblons les colonnes `2002` et `2007` sous `year` et les diff√©rentes valeurs dans `population`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_long <- df %>%\n  pivot_longer(cols = c(`2002`, `2007`), names_to = \"year\", values_to = \"population\")\n\ndf_long\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 √ó 3\n   country     year  population\n   <chr>       <chr>      <dbl>\n 1 Belgium     2002    10311970\n 2 Belgium     2007    10392226\n 3 France      2002    59925035\n 4 France      2007    61083916\n 5 Germany     2002    82350671\n 6 Germany     2007    82400996\n 7 Italy       2002    57926999\n 8 Italy       2007    58147733\n 9 Spain       2002    40152517\n10 Spain       2007    40448191\n11 Switzerland 2002     7361757\n12 Switzerland 2007     7554661\n```\n:::\n:::\n\n\nAvec l'argument `cols =` on sp√©cifie les noms des colonnes qui deviendront des modalit√©s de la variable dont le nom est d√©termin√© dans `names_to =`. `values_to =` d√©termine la variable qui contiendra les valeurs.\n\n### pivot_wider : transformer des lignes en colonnes\n\n`pivot_wider` de r√©aliser l'op√©ration inverse que `pivot_longer`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_long %>% \n  pivot_wider(names_from = \"year\", values_from = \"population\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 √ó 3\n  country       `2002`   `2007`\n  <chr>          <dbl>    <dbl>\n1 Belgium     10311970 10392226\n2 France      59925035 61083916\n3 Germany     82350671 82400996\n4 Italy       57926999 58147733\n5 Spain       40152517 40448191\n6 Switzerland  7361757  7554661\n```\n:::\n:::\n\n\nDans `names_from =` nous indiquons la variable √† partir de laquelle cr√©er des colonnes.\n\n## Combiner plusieurs tableaux de donn√©es\n\nSouvent, l'analyse de donn√©es implique plusieurs jeux de donn√©es, au lieu d'un seul. Ces diff√©rents jeux de donn√©es soivent √™tre combin√©s pour pouvoir r√©pondre √† la question qui vous int√©resse. Les diff√©rentes tables de donn√©es li√©es forment ce qu'on appelle une base de donn√©es relationnel.\n\nPour pouvoir relier les diff√©rents tables de donn√©es, ces derni√®res doivent poss√©der des cl√©s (keys) permettant d'√©tablir ce lien. Une cl√© identifie une observation de fa√ßon unique.\n\nIl y a deux types de cl√©s :\n\n-   cl√© primaire : identifie une observation de fa√ßon unique dans sa propre table.\n\n-   cl√© √©trang√®re : identifie une observation dans une autre table.\n\nPar exemple, dans les enqu√™tes du type EDS, nous pouvons avoir une table de donn√©es de m√©nage et une table de donn√©es des femmes. Le num√©ro du m√©nage dans la table m√©nage constitue la cl√© primaire. Dans la table de donn√©es des femmes, ce m√™me num√©ro constitue une cl√© √©trang√®re.\n\nNous allons utiliser deux tables de donn√©es (`personnes` et `voitures`) pour illustrer l'utilisation des jointures.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes <- tibble(\n  nom = c(\"Sylvie\", \"Sylvie\", \"Monique\", \"Gunter\", \"Rayan\", \"Rayan\"),\n  voiture = c(\"Twingo\", \"Ferrari\", \"Scenic\", \"Lada\", \"Twingo\", \"Clio\")\n)\n\nvoitures <- tibble(\n  voiture = c(\"Twingo\", \"Ferrari\", \"Clio\", \"Lada\", \"208\"),\n  vitesse = c(\"140\", \"280\", \"160\", \"85\", \"160\")\n)\n\npersonnes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 √ó 2\n  nom     voiture\n  <chr>   <chr>  \n1 Sylvie  Twingo \n2 Sylvie  Ferrari\n3 Monique Scenic \n4 Gunter  Lada   \n5 Rayan   Twingo \n6 Rayan   Clio   \n```\n:::\n\n```{.r .cell-code}\nvoitures\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 √ó 2\n  voiture vitesse\n  <chr>   <chr>  \n1 Twingo  140    \n2 Ferrari 280    \n3 Clio    160    \n4 Lada    85     \n5 208     160    \n```\n:::\n:::\n\n\n### inner_join\n\nRetourne uniquement les lignes pr√©sentes dans les deux tables.\n\n![inner_join](images/inner.PNG){fig-align=\"center\"}\n\nLorsque les cl√©s portent le m√™me nom, il n'est important de pr√©ciser cette variable dans l'appel de la fonction. Mais lorsque les cl√©s ont des noms diff√©rents, il devient alors obligatoire de pr√©ciser les noms des variables cl√©s avec l'argument `by = c(\"cle_x\" = \"cle_y\")` au sein de la fonction de jointure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes %>% inner_join(voitures)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"voiture\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 √ó 3\n  nom    voiture vitesse\n  <chr>  <chr>   <chr>  \n1 Sylvie Twingo  140    \n2 Sylvie Ferrari 280    \n3 Gunter Lada    85     \n4 Rayan  Twingo  140    \n5 Rayan  Clio    160    \n```\n:::\n:::\n\n\nEn pr√©cisant explicitement la cl√© :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes %>% inner_join(voitures, by = c(\"voiture\" = \"voiture\"))\n```\n:::\n\n\n### left_join\n\nDonne toutes les lignes de la premi√®re table avec les lignes de la deuxi√®me table si elles ont une cl√© correspondante. Les lignes de la premi√®re table sans correspondance dans la deuxi√®me auront des 'NA'. Les lignes de la deuxi√®me table sans correspondance avec la premi√®re seront supprim√©es. L'image ci-apr√®s illustre le fonctionnement de `left_join()`.\n\n![left_join](images/left.PNG){fig-align=\"center\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes %>% left_join(voitures)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"voiture\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 √ó 3\n  nom     voiture vitesse\n  <chr>   <chr>   <chr>  \n1 Sylvie  Twingo  140    \n2 Sylvie  Ferrari 280    \n3 Monique Scenic  <NA>   \n4 Gunter  Lada    85     \n5 Rayan   Twingo  140    \n6 Rayan   Clio    160    \n```\n:::\n:::\n\n\n### right_join\n\n`right_join()` est juste l'oppos√© de `left_join()`. Donne toutes les lignes de la deuxi√®me table avec les lignes de la premi√®re table si elles ont une cl√© correspondante. Les lignes de la deuxi√®me table sans correspondance dans la premi√®re auront des 'NA'. Les lignes de la premi√®re table sans correspondance avec la deuxi√®me seront supprim√©es comme le montre l'image suivante.\n\n![right_join](images/right.PNG){fig-align=\"center\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes %>% right_join(voitures)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"voiture\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 √ó 3\n  nom    voiture vitesse\n  <chr>  <chr>   <chr>  \n1 Sylvie Twingo  140    \n2 Sylvie Ferrari 280    \n3 Gunter Lada    85     \n4 Rayan  Twingo  140    \n5 Rayan  Clio    160    \n6 <NA>   208     160    \n```\n:::\n:::\n\n\n### full_join\n\n![full_join](images/full.PNG){fig-align=\"center\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes %>% full_join(voitures)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"voiture\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 √ó 3\n  nom     voiture vitesse\n  <chr>   <chr>   <chr>  \n1 Sylvie  Twingo  140    \n2 Sylvie  Ferrari 280    \n3 Monique Scenic  <NA>   \n4 Gunter  Lada    85     \n5 Rayan   Twingo  140    \n6 Rayan   Clio    160    \n7 <NA>    208     160    \n```\n:::\n:::\n\n\nRetourne toutes les lignes de deux tables, m√™me si elles ne sont pas disponibles dans l'une ou l'autre table.\n\n------------------------------------------------------------------------\n\nL'image suivante donne un rsum√© de diff√©rentes jointures mutate (qui ajoutent des colonnes) sous forme de diagramme de Venn.\n\n\\\n![diagramme de venn](images/venn-dia.PNG){fig-align=\"center\"}\n\nContrairement aux jointures vues jusqu'ici, celles qui suivent n'ajoutent pas de colonnes (variables) √† la premi√®re table de donn√©es. On les qualifie de jointures filtrantes.\n\n### semi_join\n\nRetourne les lignes de la premi√®re table qui ont des correspondances dans la deuxi√®me table, sans ajouter les colonnes de cette derni√®re.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes %>% semi_join(voitures)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"voiture\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 √ó 2\n  nom    voiture\n  <chr>  <chr>  \n1 Sylvie Twingo \n2 Sylvie Ferrari\n3 Gunter Lada   \n4 Rayan  Twingo \n5 Rayan  Clio   \n```\n:::\n:::\n\n\n### anti_join\n\nRetourne les lignes de la premi√®re table qui n'ont pas de correspondances dans la deuxi√®me table, sans ajouter les colonnes de cette derni√®re.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonnes %>% anti_join(voitures)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"voiture\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 √ó 2\n  nom     voiture\n  <chr>   <chr>  \n1 Monique Scenic \n```\n:::\n:::\n\n\n## Travailler avec les dates\n\nNous allons apprendre maintenant √† travailler avec des dates. R dispose des package facilitant la manipulation des dates. Le plus utilis√© est sans doute `lubridate`.\n\nLe package `lubridate` est une collection de fonctions pour manipuler des dates en R. Il a √©t√© d√©velopp√© pour simplifier le processus de transformation de dates dans le format le plus appropri√© pour l'analyse de donn√©es. Le package permet de facilement extraire des composantes de dates (jour, mois, ann√©e), de calculer des diff√©rences de temps entre deux dates et de convertir des dates dans diff√©rents formats.\n\nNous utiliserons la table de donn√©es `flights` contenu dans le package `nycflights13`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\nlibrary(nycflights13)\n```\n:::\n\n\n### Cr√©er une variable date\n\nIl y a trois types de donn√©es qui font r√©f√©rence √† un instant dans le temps :\n\n-   date, affich√© comme <date> dans tibble\n\n-   time, affich√© comme <time> dans tibble\n\n-   date-time, affich√© comme <dttm> dans tibble\n\nOn peut obtenir la date actuelle avec `today()` et `now()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-04-06\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-04-06 10:17:06 WAT\"\n```\n:::\n:::\n\n\nUne variable date peut √™tre cr√©√©e √† partir d'une cha√Æne de caract√®re, des composants individuels de date ou d'une autre variable date.\n\n#### A partir d'une cha√Æne de caract√®re {.unnumbered}\n\nIl y a trois fonctions qui permettent de cr√©er d'une variable date √† partir d'une cha√Æne de caract√®re. Leur nom varie selon l'ordre du jour, mois et ann√©e dans la cha√Æne de caract√®re. Il s'agit de `dmy()`, `mdy()` et `ymd()`, o√π d, m et y repr√©sentent respectivement le jour, le mois et l'ann√©e.\n\nUn exemple est donn√© ci-apr√®s :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndmy(\"21-08-2023\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-08-21\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nymd(\"2020-Feb-12\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2020-02-12\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmdy(\"July 1, 2017\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-07-01\"\n```\n:::\n:::\n\n\nPour cr√©er une date associ√© au temps, il suffit d'ajouter `hms`, `hms` ou `hm` o√π h, m et s repr√©sentent respectivement l'heure, la minute et la seconde.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndmy_hms(\"21-08-2023 10-10-25\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-08-21 10:10:25 UTC\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmdy_hm(\"July 1, 2017 16-10\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-07-01 16:10:00 UTC\"\n```\n:::\n:::\n\n\nDans la pratique, on passe g√©n√©ralement √† ces fonctions une variable contenant la cha√Æne de caract√®re qu'on souhaitre transformer en date.\n\n#### A partir de composants individuels de date {.unnumbered}\n\nAu lieu d'une seule cha√Æne de caract√®re, vous aurez parfois des composants de date dans plusieurs colonnes. C'e q'est ce que nous avons dans ces donn√©es.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>%\nselect(year, month, day, hour, minute)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 336,776 √ó 5\n    year month   day  hour minute\n   <int> <int> <int> <dbl>  <dbl>\n 1  2013     1     1     5     15\n 2  2013     1     1     5     29\n 3  2013     1     1     5     40\n 4  2013     1     1     5     45\n 5  2013     1     1     6      0\n 6  2013     1     1     5     58\n 7  2013     1     1     6      0\n 8  2013     1     1     6      0\n 9  2013     1     1     6      0\n10  2013     1     1     6      0\n# ‚Ä¶ with 336,766 more rows\n```\n:::\n:::\n\n\nUtilisez `make_date()` pour cr√©er une variable date et `make_datetime()` pour date-time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>% \n  select(year, month, day, hour, minute) %>% \n  mutate(\n    depart = make_datetime(year, month, day, hour, minute)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 336,776 √ó 6\n    year month   day  hour minute depart             \n   <int> <int> <int> <dbl>  <dbl> <dttm>             \n 1  2013     1     1     5     15 2013-01-01 05:15:00\n 2  2013     1     1     5     29 2013-01-01 05:29:00\n 3  2013     1     1     5     40 2013-01-01 05:40:00\n 4  2013     1     1     5     45 2013-01-01 05:45:00\n 5  2013     1     1     6      0 2013-01-01 06:00:00\n 6  2013     1     1     5     58 2013-01-01 05:58:00\n 7  2013     1     1     6      0 2013-01-01 06:00:00\n 8  2013     1     1     6      0 2013-01-01 06:00:00\n 9  2013     1     1     6      0 2013-01-01 06:00:00\n10  2013     1     1     6      0 2013-01-01 06:00:00\n# ‚Ä¶ with 336,766 more rows\n```\n:::\n:::\n\n\n#### A partir d'une autre variable date {.unnumbered}\n\nVous pouvez quitter d'un type date √† un type date-time ou vice-versa. Deux fonctions permettent d'acomplir cela. Il s'agit de `as_datetime()` et `as_date()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_datetime(today())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-04-06 UTC\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nas_date(now())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-04-06\"\n```\n:::\n:::\n\n\n### Extraire les composants de date\n\nIl est possible de d'extraire des composants de date comme l'ann√©e (`year()`), le mois (`month()`), le jour du mois (`mday()`), le jour de l'ann√©e (`yday()`), le jour de la semaine (`wday()`), l'heure (`hour()`), la minute et la seconde `second()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatetime <- dmy_hms(\"15-02-2023 14:25:02\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nyear(datetime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2023\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmonth(datetime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nyday(datetime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 46\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmday(datetime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwday(datetime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhour(datetime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14\n```\n:::\n:::\n\n\n`month()` et `wday()` dispose de `label =` et `abbr =`. `label = TRUE` permet d'obtenir des noms abbr√©g√©s de mois ou de jour au lieu de nombre, et `abbr = FALSE` permet d'obtenir les noms complets au lieu des abbr√©g√©s.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonth(datetime, label = T, abbr = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] f√©vrier\n12 Levels: janvier < f√©vrier < mars < avril < mai < juin < juillet < ... < d√©cembre\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwday(datetime, label = T, abbr = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] mercredi\n7 Levels: dimanche < lundi < mardi < mercredi < jeudi < ... < samedi\n```\n:::\n:::\n\n\n### Calculer la dur√©e entre deux dates\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- today() - dmy(\"25-05-1999\")\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 8717 days\n```\n:::\n\n```{.r .cell-code}\nclass(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"difftime\"\n```\n:::\n:::\n\n\nQuand vous effectuez ce calcul, vous obtenez un objet de type `difftime`. Le probl√®me avec `difftime` est qu'il donne le r√©sulat avec diff√©rentes unit√©s (seconde, minutes, ...). Pour r√©soudre ce probl√®me, vous pouvez utiliser la fonction `as.duration()` pour convertir la valeur en seconde. Et pour pouvoir effectuer des calculs, vous pouvez convertir le r√©sultat de `as.duration()` en num√©rique avec la fonction `as.numeric()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.duration(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"753148800s (~23.87 years)\"\n```\n:::\n\n```{.r .cell-code}\nas.numeric(as.duration(age))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 753148800\n```\n:::\n:::\n\n\nVous pouvez alors convertir cette valeur en n'importe quelle unit√© en consid√©rant q'une minute correspond √† 60 secondes.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}